#!/usr/bin/env python3

import hashlib
import logging
import logging.config
import os
from datetime import datetime
from dateutil.parser import parse  # type: ignore[import-untyped]

import markdown  # type: ignore[import-untyped]
from flask import Flask
from flask_bootstrap import Bootstrap5  # type: ignore[import-untyped]
from flask_migrate import Migrate  # type: ignore[import-untyped]
from flask_sqlalchemy import SQLAlchemy
from flask_wtf.csrf import CSRFProtect  # type: ignore[import-untyped]

from vulnerabilitylookup.default import get_config
from vulnerabilitylookup.vulnerabilitylookup import VulnerabilityLookup
from website import BASE_DIR
from website.web.helpers import sri_load

from .helpers import get_secret_key
from .proxied import ReverseProxied


def set_logging(
    log_path: str = "",
    log_level: int = logging.INFO,
    modules: list[str] = [],
    log_format: str = "%(asctime)s %(name)s %(levelname)s %(message)s",
) -> None:
    if not modules:
        modules = ["root", "website"]
    if log_path:
        handler: logging.Handler = logging.FileHandler(log_path)
    else:
        handler = logging.StreamHandler()
    formater = logging.Formatter(log_format)
    handler.setFormatter(formater)
    for logger_name in modules:
        logger = logging.getLogger(logger_name)
        logger.addHandler(handler)
        for handler in logger.handlers:
            handler.setLevel(log_level)
        logger.setLevel(log_level)


application: Flask = Flask(__name__)

application.wsgi_app = ReverseProxied(application.wsgi_app)  # type: ignore

# Loads the appropriate configuration
TESTING = os.environ.get("TESTING", "")
if TESTING == "gh_action":
    # Testing on GitHub Actions
    application.config[
        "SQLALCHEMY_DATABASE_URI"
    ] = "postgresql://postgres:password@localhost:5432/vulnlookuptest"
elif TESTING.endswith(".py"):
    # Testing on a local machine with configuration from a Python config file.
    # if you launch the tests with pytest the environment variable 'TESTING' is already
    # set in pyproject.toml (tool.pytest.ini_options) to `website_test.py`.
    # so you can create a file config/website_test.py with your database configuration
    application.config.from_pyfile(
        os.path.join(BASE_DIR, "config", TESTING), silent=False
    )
    set_logging(
        application.config["LOG_PATH"], log_level=application.config["LOG_LEVEL"]
    )
else:
    # The production configuration file
    application.config.from_pyfile(
        os.path.join(BASE_DIR, "config", "website.py"), silent=False
    )
    set_logging(
        application.config["LOG_PATH"], log_level=application.config["LOG_LEVEL"]
    )

application.config["SECRET_KEY"] = get_secret_key()
application.config["PUBLIC_DOMAIN"] = get_config("generic", "public_domain")


Bootstrap5(application)

# Database and migration
db = SQLAlchemy(application)
migrate = Migrate(application, db, directory="website/migrations")

# Enable CSRF protection globally
csrf = CSRFProtect(application)

vulnerabilitylookup: VulnerabilityLookup = VulnerabilityLookup()  # type: ignore[unused-ignore]


# ##### Global methods passed to Jinja


def get_sri(directory: str, filename: str) -> str:
    sha512 = sri_load()[directory][filename]
    return f"sha512-{sha512}"


application.jinja_env.globals.update(get_sri=get_sri)


# ##### Jinja custom filters


def datetimeformat(value: datetime, format: str = "%Y-%m-%d %H:%M") -> str:
    return value.strftime(format)


def string_to_datetime(value: str, format: str = "") -> str:
    now = datetime.now()
    try:
        new_date_time = parse(value)
    except Exception:
        return value
    if format:
        return datetimeformat(new_date_time, format)
    elif new_date_time.year == now.year and new_date_time.month == now.month:
        return datetimeformat(new_date_time, "%d")
    elif new_date_time.year == now.year:
        return datetimeformat(new_date_time, "%b %d")
    else:
        return datetimeformat(new_date_time)


def to_markdown(value: str) -> str:
    try:
        return markdown.markdown(value)
    except Exception:
        return value


def hash(value: str) -> str:
    m = hashlib.sha256()
    m.update(value.encode())
    return m.hexdigest()


application.jinja_env.filters["datetimeformat"] = datetimeformat
application.jinja_env.filters["string_to_datetime"] = string_to_datetime
application.jinja_env.filters["markdown"] = to_markdown
application.jinja_env.filters["hash"] = hash
