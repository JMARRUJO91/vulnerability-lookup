from typing import Any
from typing import Dict
from typing import Tuple

import logging
from sqlalchemy import exc
from flask_restx import fields  # type: ignore[import-untyped]
from flask_restx import abort
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource

from website.models import User
from website.web.bootstrap import db
from website.web.api.v1.common import metada_params_model
from website.web.api.v1.types import ResultType
from website.web.permissions import admin_permission

logger = logging.getLogger(__name__)

user_ns = Namespace("user", description="user related operations")


# Argument Parsing
parser = reqparse.RequestParser()
parser.add_argument("login", type=str, location="json", help="Login.")
parser.add_argument(
    "name", type=str, location="json", help="Display name (firstname, lastname)."
)
parser.add_argument("organisation", type=str, location="json", help="Organisation.")
parser.add_argument("email", type=str, location="json", help="Email.")


# Response marshalling
user_params_model = {
    "id": fields.Integer(description="User id."),
    "login": fields.String(description="User login."),
    "name": fields.String(description="User name."),
    "organisation": fields.String(description="User organisation."),
    "email": fields.String(description="User email."),
    "apikey": fields.String(description="User API key.", readonly=True),
    "is_admin": fields.Boolean(
        description="Boolean specifying whether the user is administrator."
    ),
    "is_reporter": fields.Boolean(
        description="Boolean specifying whether the user is administrator."
    ),
    "is_commenter": fields.Boolean(
        description="Boolean specifying whether the user is administrator."
    ),
    "created_at": fields.DateTime(
        description="Creation time of the user.", readonly=True
    ),
    "last_seen": fields.DateTime(
        description="Last seen time of the user.", readonly=True
    ),
}
user = user_ns.model("User", user_params_model)
metadata = user_ns.model("metadata", metada_params_model)

user_list_fields = user_ns.model(
    "UsersList",
    {
        "metadata": fields.Nested(
            metadata, description="Metada related to the result."
        ),
        "data": fields.List(
            fields.Nested(user, skip_none=True), description="List of users."
        ),
    },
)


@user_ns.route("/user/")
class UsersList(Resource):  # type: ignore[misc]
    @user_ns.doc("list_users")  # type: ignore[misc]
    @user_ns.doc(
        responses={
            200: "Success.",
            403: "Admin permission required.",
        }
    )  # type: ignore[misc]
    @user_ns.marshal_list_with(user_list_fields)  # type: ignore[misc]
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    def get(self) -> Tuple[ResultType, int]:
        """List all users. Only available to administrators."""
        args = parser.parse_args()
        offset = args.pop("page", 1) - 1
        limit = args.pop("per_page", 10)

        result: ResultType = {
            "data": [],
            "metadata": {
                "count": 0,
                "offset": offset,
                "limit": limit,
            },
        }

        results = []
        count = 0
        query = User.query
        total = query.count()
        query = query.limit(limit)
        results = query.offset(offset * limit)
        count = total

        result["data"] = results
        result["metadata"]["count"] = count

        return result, 200

    @user_ns.doc(description="Create a non-admin user.")  # type: ignore[misc]
    @user_ns.doc(
        responses={
            201: "Success.",
        }
    )  # type: ignore[misc]
    @user_ns.expect(parser)  # type: ignore[misc]
    @user_ns.marshal_list_with(user, code=201)  # type: ignore[misc]
    def post(self) -> Tuple[Dict[Any, Any], int]:
        """Create a non-admin user."""
        try:
            new_user = User(
                **user_ns.payload, pwdhash="", is_active=False, is_confirmed=False
            )
            db.session.add(new_user)
            db.session.commit()
        except AssertionError as e:
            return abort(400, f"{e}")
        except exc.IntegrityError:
            db.session.rollback()
            return abort(400, f"Impossible to create the user.")

        return new_user, 201
